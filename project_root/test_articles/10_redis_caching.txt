Кэширование с Redis: стратегии, структуры данных и производительность

Redis — in-memory база данных, используемая для кэширования, очередей сообщений, pub/sub, session storage. Хранение данных в оперативной памяти обеспечивает субмиллисекундные задержки, на порядки быстрее дисковых баз данных. Типичные use cases — кэш результатов дорогих запросов, счётчики, временные данные.

Cache-aside паттерн: приложение проверяет кэш, при промахе запрашивает базу данных, сохраняет в кэш. GET /users/123 сначала пытается redis.get('user:123'), при отсутствии запрашивает PostgreSQL, затем redis.set('user:123', data, ex=3600) с TTL 1 час. Это сокращает нагрузку на БД на 90%+ для часто читаемых данных.

Write-through кэш синхронно записывает в БД и кэш при каждом обновлении. Это гарантирует консистентность, но замедляет записи. Write-behind (write-back) асинхронно сбрасывает изменения, ускоряя записи, но рискует потерей при крашах. Выбор зависит от tolerance к несогласованности и latency requirements.

Redis поддерживает сложные структуры данных. Strings для простых пар ключ-значение. Hashes для объектов (HSET user:123 name "John"). Lists для очередей (LPUSH, RPOP). Sets для уникальных элементов (SADD, SMEMBERS). Sorted Sets для рейтингов (ZADD, ZRANGE). Использование правильной структуры критично для производительности.

Eviction policies определяют, что удалять при заполнении памяти. LRU (Least Recently Used) вытесняет редко используемые ключи. LFU (Least Frequently Used) учитывает частоту обращений. TTL (Time To Live) автоматически удаляет просроченные ключи. volatile-lru применяет LRU только к ключам с TTL, защищая постоянные данные.

Redis Cluster распределяет данные по шардам для горизонтального масштабирования. 16384 hash slot'ов равномерно распределены между нодами. Клиент перенаправляется на правильный шард по hash ключа. Репликация обеспечивает отказоустойчивость — master реплицирует данные на slaves, failover автоматически промотит slave при падении master.
